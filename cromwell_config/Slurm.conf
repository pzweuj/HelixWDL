# CROMWELL CONFIG
# pzweuj
# 20250724
include required(classpath("application"))

# Cromwell HTTP server settings
webservice {
  port = 8000
}

# LSF config
backend {
  default = slurm
  providers {
    slurm {
      actor-factory = "cromwell.backend.impl.sfs.config.ConfigBackendLifecycleActorFactory"
      
      # 默认的配置
      config {
        # 默认的运行路径
        root = "/path/to/run_project"

        # 默认的runtime
        runtime-attributes = """
        Int runtime_minutes = 1440
        Int cpus = 2
        Int requested_memory_mb_per_core = 8000
        String? binding
        String queue = "normal"
        String singularity_image_dir = "/opt/singularity/images"
        Boolean auto_build_singularity = true
        """
        
        run-in-background = true
        kill = "scancel ${job_id}"
        check-alive = "squeue -j ${job_id}"
        job-id-regex = "Submitted batch job (\\d+).*"

        # 投递命令
        submit = """
        # Singularity支持的核心函数库
        
        # 镜像名称转换函数：将Docker镜像名转换为SIF文件名
        docker_to_sif_name() {
            local docker_image="$1"
            # 移除协议前缀，替换特殊字符为下划线，添加.sif后缀
            echo "${docker_image}" | sed 's|https\?://||g' | sed 's|[/:@]|_|g' | sed 's/$/.sif/'
        }
        
        # 容器运行时检测函数：按优先级选择可用的容器运行时
        select_container_runtime() {
            local container="$1"
            
            # 如果是SIF文件，直接使用singularity
            if [[ "${container}" == *.sif ]]; then
                echo "singularity"
                return 0
            fi
            
            # 检查podman（优先级最高）
            if command -v podman >/dev/null 2>&1; then
                echo "podman"
                return 0
            fi
            
            # 检查docker（优先级第二）
            if command -v docker >/dev/null 2>&1; then
                echo "docker"
                return 0
            fi
            
            # 检查singularity（回退选项）
            if command -v singularity >/dev/null 2>&1; then
                echo "singularity"
                return 0
            fi
            
            echo "none"
            return 1
        }
        
        # SIF文件查找和构建函数：支持自动构建缺失的镜像
        get_singularity_image() {
            local docker_image="$1"
            local image_dir="$2"
            local auto_build="$3"
            
            local sif_name=$(docker_to_sif_name "${docker_image}")
            local sif_path="${image_dir}/${sif_name}"
            
            echo "查找Singularity镜像: ${docker_image} -> ${sif_path}" >&2
            
            # 检查SIF文件是否存在
            if [ -f "${sif_path}" ]; then
                echo "找到现有SIF文件: ${sif_path}" >&2
                echo "${sif_path}"
                return 0
            fi
            
            # 如果不存在且允许自动构建
            if [ "${auto_build}" = "true" ]; then
                echo "开始构建Singularity镜像: ${docker_image} -> ${sif_path}" >&2
                
                # 确保目录存在
                mkdir -p "${image_dir}"
                
                # 构建SIF文件
                if singularity build "${sif_path}" "docker://${docker_image}"; then
                    echo "成功构建SIF文件: ${sif_path}" >&2
                    echo "${sif_path}"
                    return 0
                else
                    echo "错误：无法构建Singularity镜像 ${docker_image}" >&2
                    return 1
                fi
            else
                echo "错误：找不到SIF文件 ${sif_path}，且自动构建已禁用" >&2
                return 1
            fi
        }
        
        # binding格式转换函数：将Singularity格式转换为Docker/Podman格式
        convert_binding_format() {
            local binding="$1"
            local runtime="$2"
            
            if [ -z "${binding}" ]; then
                echo ""
                return 0
            fi
            
            case "${runtime}" in
                "singularity")
                    # Singularity使用逗号分隔的格式，直接返回
                    echo "${binding}"
                    ;;
                "podman"|"docker")
                    # Docker/Podman需要将逗号分隔的绑定转换为多个-v参数
                    local docker_bindings=""
                    IFS=',' read -ra BINDINGS <<< "${binding}"
                    for bind in "${BINDINGS[@]}"; do
                        # 去除前后空格
                        bind=$(echo "${bind}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                        if [ -n "${bind}" ]; then
                            docker_bindings="${docker_bindings} -v ${bind}"
                        fi
                    done
                    echo "${docker_bindings}"
                    ;;
            esac
        }
        
        # 统一的容器执行函数
        run_container() {
            local container="$1"
            local script="$2"
            local cwd="$3"
            local binding="$4"
            local image_dir="$5"
            local auto_build="$6"
            
            echo "开始容器运行时检测，容器: ${container}" >&2
            local runtime=$(select_container_runtime "${container}")
            echo "选择的容器运行时: ${runtime}" >&2
            
            # 转换binding格式
            local converted_binding=$(convert_binding_format "${binding}" "${runtime}")
            echo "原始binding: ${binding}" >&2
            echo "转换后binding: ${converted_binding}" >&2
            
            case "${runtime}" in
                "singularity")
                    if [[ "${container}" != *.sif ]]; then
                        # 需要查找或构建SIF文件
                        container=$(get_singularity_image "${container}" "${image_dir}" "${auto_build}")
                        if [ $? -ne 0 ]; then
                            echo "错误：无法获取Singularity镜像" >&2
                            return 1
                        fi
                    fi
                    
                    echo "使用Singularity运行容器: ${container}" >&2
                    if [ -z "${converted_binding}" ]; then
                        echo "singularity exec --bind ${cwd}:${cwd} ${container} /usr/bin/env bash ${script}"
                    else
                        echo "singularity exec --bind ${cwd}:${cwd},${converted_binding} ${container} /usr/bin/env bash ${script}"
                    fi
                    ;;
                "podman"|"docker")
                    echo "使用${runtime}运行容器: ${container}" >&2
                    if [ -z "${converted_binding}" ]; then
                        echo "${runtime} run --rm -v ${cwd}:${cwd} ${container} /usr/bin/env bash ${script}"
                    else
                        # 构建完整的docker命令，包含多个-v参数
                        echo "${runtime} run --rm -v ${cwd}:${cwd}${converted_binding} ${container} /usr/bin/env bash ${script}"
                    fi
                    ;;
                "none")
                    echo "错误：没有可用的容器运行时（podman、docker、singularity都不可用）" >&2
                    return 1
                    ;;
            esac
        }
        
        # 主执行逻辑
        if [ -z "${container}" ]; then
          # 无容器运行 - 通过Slurm提交
          echo "无容器模式，通过Slurm提交脚本" >&2
          sbatch \
            -J ${job_name} \
            -D ${cwd} \
            -o ${out} \
            -e ${err} \
            -t ${runtime_minutes} \
            -p ${queue} \
            -n ${cpus} \
            --mem-per-cpu=${requested_memory_mb_per_core} \
            --wrap "/usr/bin/env bash ${script}"
        else
          # 使用容器运行，调用统一的容器执行函数获取容器命令
          CONTAINER_RUN_CMD=$(run_container "${container}" "${script}" "${cwd}" "${binding}" "${singularity_image_dir}" "${auto_build_singularity}")
          if [ $? -ne 0 ]; then
            echo "错误：容器执行命令生成失败" >&2
            exit 1
          fi
          
          echo "通过Slurm提交容器任务" >&2
          sbatch \
            -J ${job_name} \
            -D ${cwd} \
            -o ${out} \
            -e ${err} \
            -t ${runtime_minutes} \
            -p ${queue} \
            -n ${cpus} \
            --mem-per-cpu=${requested_memory_mb_per_core} \
            --wrap "${CONTAINER_RUN_CMD}"
        fi
        """
      }

      filesystems {
        local {
          localization: [
            "hard-link", "copy"
          ]

          caching {
            duplication-strategy: [
              "hard-link", "copy"
            ]

            hashing-strategy: "file"
            check-sibling-md5: false
          }
        }
      }
    }
  }
}
