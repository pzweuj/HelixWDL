# CROMWELL CONFIG FOR SINGLE NODE
# pzweuj
# 20250724
include required(classpath("application"))

# Cromwell HTTP server settings
webservice {
  port = 8001
}

# Single node local execution config
backend {
  default = Local
  providers {
    Local {
      actor-factory = "cromwell.backend.impl.sfs.config.ConfigBackendLifecycleActorFactory"
      
      # 默认的配置
      config {
        # 默认的运行路径
        root = "/path/to/run_project"

        # 默认的runtime
        runtime-attributes = """
        Int runtime_minutes = 1440
        Int cpus = 2
        Int requested_memory_mb = 8000
        String? binding
        String singularity_image_dir = "/opt/singularity/images"
        Boolean auto_build_singularity = true
        """
        
        run-in-background = true
        
        # 本地执行不需要作业调度系统的kill和check命令
        # 使用默认的进程管理

        # 投递命令 - 本地直接执行
        submit = """
        # Singularity支持的核心函数库
        
        # 镜像名称转换函数：将Docker镜像名转换为SIF文件名
        docker_to_sif_name() {
            local docker_image="$1"
            # 移除协议前缀，替换特殊字符为下划线，添加.sif后缀
            echo "${docker_image}" | sed 's|https\?://||g' | sed 's|[/:@]|_|g' | sed 's/$/.sif/'
        }
        
        # 容器运行时检测函数：按优先级选择可用的容器运行时
        select_container_runtime() {
            local container="$1"
            
            # 如果是SIF文件，直接使用singularity
            if [[ "${container}" == *.sif ]]; then
                echo "singularity"
                return 0
            fi
            
            # 检查podman（优先级最高）
            if command -v podman >/dev/null 2>&1; then
                echo "podman"
                return 0
            fi
            
            # 检查docker（优先级第二）
            if command -v docker >/dev/null 2>&1; then
                echo "docker"
                return 0
            fi
            
            # 检查singularity（回退选项）
            if command -v singularity >/dev/null 2>&1; then
                echo "singularity"
                return 0
            fi
            
            echo "none"
            return 1
        }
        
        # SIF文件查找和构建函数：支持自动构建缺失的镜像
        get_singularity_image() {
            local docker_image="$1"
            local image_dir="$2"
            local auto_build="$3"
            
            local sif_name=$(docker_to_sif_name "${docker_image}")
            local sif_path="${image_dir}/${sif_name}"
            
            echo "查找Singularity镜像: ${docker_image} -> ${sif_path}" >&2
            
            # 检查SIF文件是否存在
            if [ -f "${sif_path}" ]; then
                echo "找到现有SIF文件: ${sif_path}" >&2
                echo "${sif_path}"
                return 0
            fi
            
            # 如果不存在且允许自动构建
            if [ "${auto_build}" = "true" ]; then
                echo "开始构建Singularity镜像: ${docker_image} -> ${sif_path}" >&2
                
                # 确保目录存在
                mkdir -p "${image_dir}"
                
                # 构建SIF文件
                if singularity build "${sif_path}" "docker://${docker_image}"; then
                    echo "成功构建SIF文件: ${sif_path}" >&2
                    echo "${sif_path}"
                    return 0
                else
                    echo "错误：无法构建Singularity镜像 ${docker_image}" >&2
                    return 1
                fi
            else
                echo "错误：找不到SIF文件 ${sif_path}，且自动构建已禁用" >&2
                return 1
            fi
        }
        
        # binding格式转换函数：将Singularity格式转换为Docker/Podman格式
        convert_binding_format() {
            local binding="$1"
            local runtime="$2"
            
            if [ -z "${binding}" ]; then
                echo ""
                return 0
            fi
            
            case "${runtime}" in
                "singularity")
                    # Singularity使用逗号分隔的格式，直接返回
                    echo "${binding}"
                    ;;
                "podman"|"docker")
                    # Docker/Podman需要将逗号分隔的绑定转换为多个-v参数
                    local docker_bindings=""
                    IFS=',' read -ra BINDINGS <<< "${binding}"
                    for bind in "${BINDINGS[@]}"; do
                        # 去除前后空格
                        bind=$(echo "${bind}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                        if [ -n "${bind}" ]; then
                            docker_bindings="${docker_bindings} -v ${bind}"
                        fi
                    done
                    echo "${docker_bindings}"
                    ;;
            esac
        }
        
        # 统一的容器执行函数
        run_container() {
            local container="$1"
            local script="$2"
            local cwd="$3"
            local binding="$4"
            local image_dir="$5"
            local auto_build="$6"
            
            echo "开始容器运行时检测，容器: ${container}" >&2
            local runtime=$(select_container_runtime "${container}")
            echo "选择的容器运行时: ${runtime}" >&2
            
            # 转换binding格式
            local converted_binding=$(convert_binding_format "${binding}" "${runtime}")
            echo "原始binding: ${binding}" >&2
            echo "转换后binding: ${converted_binding}" >&2
            
            case "${runtime}" in
                "singularity")
                    if [[ "${container}" != *.sif ]]; then
                        # 需要查找或构建SIF文件
                        container=$(get_singularity_image "${container}" "${image_dir}" "${auto_build}")
                        if [ $? -ne 0 ]; then
                            echo "错误：无法获取Singularity镜像" >&2
                            return 1
                        fi
                    fi
                    
                    echo "使用Singularity运行容器: ${container}" >&2
                    if [ -z "${converted_binding}" ]; then
                        singularity exec --bind "${cwd}:${cwd}" "${container}" /usr/bin/env bash "${script}"
                    else
                        singularity exec --bind "${cwd}:${cwd},${converted_binding}" "${container}" /usr/bin/env bash "${script}"
                    fi
                    ;;
                "podman"|"docker")
                    echo "使用${runtime}运行容器: ${container}" >&2
                    if [ -z "${converted_binding}" ]; then
                        "${runtime}" run --rm -v "${cwd}:${cwd}" "${container}" /usr/bin/env bash "${script}"
                    else
                        # 使用eval来正确处理多个-v参数
                        eval "${runtime} run --rm -v \"${cwd}:${cwd}\" ${converted_binding} \"${container}\" /usr/bin/env bash \"${script}\""
                    fi
                    ;;
                "none")
                    echo "错误：没有可用的容器运行时（podman、docker、singularity都不可用）" >&2
                    return 1
                    ;;
            esac
        }
        
        # 主执行逻辑
        if [ -z "${container}" ]; then
          # 无容器运行 - 直接本地执行
          echo "无容器模式，直接执行脚本" >&2
          /usr/bin/env bash ${script}
        else
          # 使用容器运行，调用统一的容器执行函数
          run_container "${container}" "${script}" "${cwd}" "${binding}" "${singularity_image_dir}" "${auto_build_singularity}"
        fi
        """

        # 本地执行的并发控制 || 对于单机模式运行时，应充分考虑单机的总线程数，以及任务分配的线程数，决定下面这个值
        concurrent-job-limit = 1
      }

      filesystems {
        local {
          localization: [
            "hard-link", "copy"
          ]

          caching {
            duplication-strategy: [
              "hard-link", "copy"
            ]

            hashing-strategy: "file"
            check-sibling-md5: false
          }
        }
      }
    }
  }
}

# 数据库配置 - 使用内存数据库适合单机使用
database {
  profile = "slick.jdbc.HsqldbProfile$"
  db {
    driver = "org.hsqldb.jdbcDriver"
    url = "jdbc:hsqldb:mem:cromwell-db;shutdown=true;hsqldb.tx=mvcc"
    connectionTimeout = 1000
    numThreads = 1
  }
}

# 工作流选项
workflow-options {
  # 本地执行的工作流选项
  workflow-log-dir = "cromwell-workflow-logs"
  workflow-log-temporary = false
}

# 系统配置
system {
  # 适合单机的系统配置
  io {
    number-of-requests = 100000
    per-request-bytes = 100000
  }
  
  # 减少内存使用
  max-concurrent-workflows = 10
  max-workflow-launch-count = 50
  
  # 新工作流轮询间隔
  new-workflow-poll-rate = 20
  
  # 作业重试配置
  job-restart {
    max-retries = 3
    backoff {
      min = "3 seconds"
      max = "30 seconds"
      multiplier = 2.0
      randomization-factor = 0.1
    }
  }
}

# 调用缓存配置
call-caching {
  enabled = true
  invalidate-bad-cache-results = true
}